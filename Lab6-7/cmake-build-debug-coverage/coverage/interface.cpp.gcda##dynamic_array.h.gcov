        -:    0:Source:D:/Programming n shit/UBB/Anul 1/OOP/Lab6-7/dynamic_array.h
        -:    0:Graph:D:\Programming n shit\UBB\Anul 1\OOP\Lab6-7\cmake-build-debug-coverage\CMakeFiles\Lab6_7.dir\Interface\interface.cpp.gcno
        -:    0:Data:D:\Programming n shit\UBB\Anul 1\OOP\Lab6-7\cmake-build-debug-coverage\CMakeFiles\Lab6_7.dir\Interface\interface.cpp.gcda
        -:    0:Runs:1
        -:    1:#pragma once
        -:    2:#include <functional>
        -:    3:#include <iostream>
        -:    4:#include <cstring>
        -:    5:
        -:    6://Iterator
        -:    7:template<typename array>
        -:    8:class array_iterator{
        -:    9:public:
        -:   10:    using value_type = typename array::value_pointer;
        -:   11:    using value_pointer = value_type*;
        -:   12:    using value_reference = typename array::value_type&;
        -:   13:
        -:   14:private:
        -:   15:    value_pointer iterator_pointer;
        -:   16:
        -:   17:public:
        -:   18:
        -:   19:    /**
        -:   20:     * Constructor for array iterator.
        -:   21:     * @param ptr Pointer to array.
        -:   22:     */
        -:   23:    explicit array_iterator(value_pointer ptr):iterator_pointer(ptr) {}
        -:   24:
        -:   25:    /**
        -:   26:     * Allows use of dereference*  operator.
        -:   27:     * @return Dereferenced value.
        -:   28:     */
        -:   29:    typename array::value_type& operator*(){
        -:   30:        return **iterator_pointer;
        -:   31:    }
        -:   32:
        -:   33:    /**
        -:   34:     * Alows use of rvalue ++ operator.
        -:   35:     * @return Returns incremented pointer.
        -:   36:     */
        -:   37:    array_iterator& operator++(){
        -:   38:        iterator_pointer++;
        -:   39:        return *this;
        -:   40:    }
        -:   41:
        -:   42:    /**
        -:   43:     * Alows use of lvalue ++ operator.
        -:   44:     * @return Returns pointer before incrementation.
        -:   45:     */
        -:   46:    array_iterator operator++(int){
        -:   47:        array_iterator temp = *this;
        -:   48:        ++(*this);
        -:   49:        return temp;
        -:   50:    }
        -:   51:
        -:   52:    /**
        -:   53:     * Alows use of rvalue -- operator.
        -:   54:     * @return Returns decremented pointer.
        -:   55:     */
        -:   56:    array_iterator& operator--(){
        -:   57:        iterator_pointer--;
        -:   58:        return *this;
        -:   59:    }
        -:   60:
        -:   61:    /**
        -:   62:     * Alows use of lvalue -- operator.
        -:   63:     * @return Returns pointer before decrementation.
        -:   64:     */
        -:   65:    array_iterator operator--(int){
        -:   66:        array_iterator temp = *this;
        -:   67:        --(*this);
        -:   68:        return temp;
        -:   69:    }
        -:   70:
        -:   71:    /**
        -:   72:     * Allows subtraction between pointer and integer.
        -:   73:     * @param int_value Integer to be subtracted.
        -:   74:     * @return Returns pointer after subtraction.
        -:   75:     */
        -:   76:    value_pointer operator-(long long int_value){
        -:   77:        return iterator_pointer - int_value;
        -:   78:    }
        -:   79:
        -:   80:    /**
        -:   81:     * Allows addition between pointer and integer.
        -:   82:     * @param int_value Integer to be added.
        -:   83:     * @return Returns pointer after addition.
        -:   84:     */
        -:   85:    value_pointer operator+(long long int_value){
        -:   86:        return iterator_pointer + int_value;
        -:   87:    }
        -:   88:
        -:   89:    /**
        -:   90:     * Allows subtraction between 2 pointers
        -:   91:     * @param other Pointer to be subtracted
        -:   92:     * @return Returns pointer after subtraction
        -:   93:     */
        -:   94:    int operator-(array_iterator other){
        -:   95:        return iterator_pointer - other.iterator_pointer;
        -:   96:    }
        -:   97:
        -:   98:    /**
        -:   99:     * Allows use of operator [] to access iterator elements.
        -:  100:     * @param index Index at which element is situated.
        -:  101:     * @return Reference of element at given index.
        -:  102:     */
        -:  103:    value_reference operator[](long long index){
        -:  104:        return **(iterator_pointer+index);
        -:  105:    }
        -:  106:
        -:  107:    /**
        -:  108:     * Allows use of < operator.
        -:  109:     * @param other Rvalue iterator.
        -:  110:     * @return Result of comparison.
        -:  111:     */
        -:  112:    bool operator < (const array_iterator& other) const{
        -:  113:        return iterator_pointer<other.iterator_pointer;
        -:  114:    }
        -:  115:
        -:  116:    /**
        -:  117:     * Allows use of -> operator.
        -:  118:     * @return (*iterator).
        -:  119:     */
        -:  120:    value_type operator->() const{
        -:  121:
        -:  122:        return *iterator_pointer;
        -:  123:    }
        -:  124:
        -:  125:    /**
        -:  126:     * Allows use of += operation.
        -:  127:     * @param int_value Integer to be added.
        -:  128:     * @return Iterator pointer after operation.
        -:  129:     */
        -:  130:    value_pointer operator+=(long long int_value){
        -:  131:        iterator_pointer += int_value;
        -:  132:        return iterator_pointer;
        -:  133:    }
        -:  134:
        -:  135:    /**
        -:  136:     * Allows use of -= operation.
        -:  137:     * @param int_value Integer to be subtracted.
        -:  138:     * @return Iterator pointer after operation.
        -:  139:     */
        -:  140:    value_pointer operator-=(long long int_value){
        -:  141:        iterator_pointer -= int_value;
        -:  142:        return iterator_pointer;
        -:  143:    }
        -:  144:
        -:  145:    /**
        -:  146:     * Allows use of -= operation between iterators.
        -:  147:     * @param other Iterator to be subtracted.
        -:  148:     * @return Iterator pointer after operation.
        -:  149:     */
        -:  150:    value_pointer operator-=(const array_iterator other){
        -:  151:        iterator_pointer -= other;
        -:  152:        return iterator_pointer;
        -:  153:    }
        -:  154:
        -:  155:    /**
        -:  156:     * Allows use of == operator.
        -:  157:     * @param other Rvalue iterator.
        -:  158:     * @return Result of comparison.
        -:  159:     */
        -:  160:    bool operator == (const array_iterator& other) const{
        -:  161:        return iterator_pointer==other.iterator_pointer;
        -:  162:    }
        -:  163:
        -:  164:    /**
        -:  165:     * Allows use of != operator.
        -:  166:     * @param other Rvalue iterator.
        -:  167:     * @return Result of comparison.
        -:  168:     */
        -:  169:    bool operator != (const array_iterator& other) const{
        -:  170:        return iterator_pointer!=other.iterator_pointer;
        -:  171:    }
        -:  172:
        -:  173:    /**
        -:  174:     * Allows use of <= operator.
        -:  175:     * @param other Rvalue iterator.
        -:  176:     * @return Result of comparison.
        -:  177:     */
        -:  178:    bool operator <= (const array_iterator& other) const{
        -:  179:        return iterator_pointer<=other.iterator_pointer;
        -:  180:    }
        -:  181:
        -:  182:    /**
        -:  183:     * Allows use of >= operator.
        -:  184:     * @param other Rvalue iterator.
        -:  185:     * @return Result of comparison.
        -:  186:     */
        -:  187:    bool operator >= (const array_iterator& other) const{
        -:  188:        return iterator_pointer>=other.iterator_pointer;
        -:  189:    }
        -:  190:
        -:  191:    /**
        -:  192:     * Allows use of > operator.
        -:  193:     * @param other Rvalue iterator.
        -:  194:     * @return Result of comparison.
        -:  195:     */
        -:  196:    bool operator > (const array_iterator& other) const{
        -:  197:        return iterator_pointer>other.iterator_pointer;
        -:  198:    }
        -:  199:};
        -:  200:
        -:  201:template <typename T>
        -:  202:class array {
        -:  203:public:
        -:  204:    using value_type = T;
        -:  205:    using value_pointer = T*;
        -:  206:    using iterator = array_iterator<array<T>>;
        -:  207:
        -:  208:private:
        -:  209:    //representation
        -:  210:    value_pointer *list = nullptr;
        -:  211:    long long list_size;
        -:  212:    long long list_capacity;
        -:  213:
        -:  214://Functions
        -:  215:private:
        -:  216:
        -:  217:    /**
        -:  218:     * Allocates more space for internal array and copies all elements.
        -:  219:     * @param new_capacity New maximum size.\n
        -:  220:     * Must be greater than old capacity.
        -:  221:     */
function _ZN5arrayI6tenantE7reallocEx called 0 returned 0% blocks executed 0%
    #####:  222:    void realloc(const long long new_capacity) {
    #####:  223:        auto new_list = (value_pointer *)::operator new(new_capacity * sizeof(value_pointer));
    %%%%%:  223-block  0
call    0 never executed
        -:  224:
    #####:  225:        for (auto i = 0; i < list_size; i++){
    %%%%%:  225-block  0
branch  0 never executed
branch  1 never executed
    #####:  226:            new_list[i] = list[i];
    %%%%%:  226-block  0
        -:  227:        }
        -:  228:
    #####:  229:        ::operator delete(list, list_capacity * sizeof(value_pointer));
    %%%%%:  229-block  0
call    0 never executed
    #####:  230:        list = new_list;
    #####:  231:        list_capacity = new_capacity;
    #####:  232:    }
        -:  233:
        -:  234:    /**
        -:  235:     * Checks if given index is in the array scope.
        -:  236:     * @param index Index to be checked.
        -:  237:     */
        -:  238:    void index_check(long long index) {
        -:  239:        //check if index is out of range and throws out_of_range exception as needed
        -:  240:        if (index < 0 || index >= list_size)
        -:  241:            throw std::out_of_range("index err");
        -:  242:    }
        -:  243:
        -:  244:    /**
        -:  245:     * Swaps the values of the two given pointers.
        -:  246:     * @param a First pointer.
        -:  247:     * @param b Second pointer.
        -:  248:     */
        -:  249:    void swap(value_pointer& a, value_pointer& b){
        -:  250:        value_pointer temp = a;
        -:  251:        a = b;
        -:  252:        b = temp;
        -:  253:    }
        -:  254:
        -:  255:public:
        -:  256:
        -:  257:    /**
        -:  258:     * Creates and returns an object of class array.
        -:  259:     */
        -:  260:    array() {
        -:  261:        list_size = 0;
        -:  262:        list_capacity = 140;
        -:  263:        realloc(list_capacity);
        -:  264:    }
        -:  265:
        -:  266:    /**
        -:  267:     * Copy constructor.
        -:  268:     * @param other Other class to be copied.
        -:  269:     */
function _ZN5arrayI6tenantEC1ERKS1_ called 3 returned 100% blocks executed 50%
        3:  270:    array(const array<value_type> &other) {
        3:  271:        list_size = 0;
        3:  272:        list_capacity = other.list_capacity;
        3:  273:        realloc(list_capacity);
        3:  273-block  0
call    0 returned 3
        3:  274:        list_size = other.list_size;
       3*:  275:        for (auto i = 0; i < list_size; i++) {
    %%%%%:  275-block  0
        3:  275-block  1
branch  0 taken 0
branch  1 taken 3 (fallthrough)
    #####:  276:            list[i] = (value_pointer) ::operator new(sizeof(value_type));
    %%%%%:  276-block  0
call    0 never executed
    #####:  277:            new(list[i]) value_type(*other.list[i]);
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    $$$$$:  277-block  0
call    4 never executed
        -:  278:        }
        3:  279:    }
        3:  279-block  0
        -:  280:
        -:  281:    /**
        -:  282:     * Allows use of == operator between arrays.
        -:  283:     * @param other Array to be compared.
        -:  284:     * @return True if both arrays contain the same list.\na
        -:  285:     * False otherwise.
        -:  286:     */
        -:  287:    bool operator==(const array<value_type> &other) const{
        -:  288:
        -:  289:        if(list_size!=other.list_size)
        -:  290:            return false;
        -:  291:
        -:  292:        for(auto i = 0; i <list_size; i++)
        -:  293:            if (*list[i] != *other.list[i])
        -:  294:                return false;
        -:  295:
        -:  296:
        -:  297:        return true;
        -:  298:    }
        -:  299:
        -:  300:    /**
        -:  301:     * Copy constructor.
        -:  302:     * @param other Array to be copied.
        -:  303:     * @return Returns destination array reference after copy.
        -:  304:     */
        -:  305:    array& operator=(const array<value_type> &other){
        -:  306:        if(this == &other)
        -:  307:            return *this;
        -:  308:        clear();
        -:  309:        for(auto i = 0; i < other.list_size; i++){
        -:  310:            push_back(*other.list[i]);
        -:  311:        }
        -:  312:        list_size = other.list_size;
        -:  313:        return *this;
        -:  314:    }
        -:  315:
        -:  316:    /**
        -:  317:     * Destroys object of class array.
        -:  318:     */
        -:  319:    ~array() {
        -:  320:        clear();
        -:  321:        ::operator delete(list, list_capacity * sizeof(value_pointer));
        -:  322:        //delete[] list;
        -:  323:    }
        -:  324:
        -:  325:    /**
        -:  326:     * Destroys all elements of the array.
        -:  327:     */
        -:  328:    void clear() {
        -:  329:        for (auto i = 0; i < list_size; i++) {
        -:  330:            list[i]->~T();
        -:  331:            ::operator delete(list[i], sizeof(value_type));
        -:  332:        }
        -:  333:        list_size = 0;
        -:  334:    }
        -:  335:
        -:  336:    /**
        -:  337:     * Returns the number of elements currently in the array.
        -:  338:     * @return Number of elements.
        -:  339:     */
        -:  340:    long long size() {
        -:  341:        return list_size;
        -:  342:    }
        -:  343:
        -:  344:    /**
        -:  345:     * Checks if list is empty
        -:  346:     * @return Emptiness of string
        -:  347:     */
        -:  348:    bool empty() {
        -:  349:        if(list_size)
        -:  350:            return false;
        -:  351:        return true;
        -:  352:    }
        -:  353:
        -:  354:    /**
        -:  355:     * Inserts given value as the last element by copying.
        -:  356:     * @param value Element to be inserted.
        -:  357:     */
        -:  358:    void push_back(const value_type &value) {
        -:  359:
        -:  360:        if (list_size >= list_capacity) {
        -:  361:            realloc(2 * list_capacity);
        -:  362:        }
        -:  363:        list[list_size] = (value_pointer) ::operator new(sizeof(value_type));
        -:  364:        new(list[list_size++]) value_type(value);
        -:  365:    }
        -:  366:
        -:  367:    /**
        -:  368:     * Inserts given value as the last element by moving.
        -:  369:     * @param value Element to be inserted.
        -:  370:     */
        -:  371:    void push_back(value_type &&value) {
        -:  372:
        -:  373:        if (list_size >= list_capacity) {
        -:  374:            realloc(2 * list_capacity);
        -:  375:        }
        -:  376:        list[list_size] = (value_pointer) ::operator new(sizeof(value_type));
        -:  377:        new(list[list_size++]) value_type(std::move(value));
        -:  378:    }
        -:  379:
        -:  380:    template<typename... Args>
        -:  381:    void emplace_back(Args&&... args){
        -:  382:        if (list_size >= list_capacity) {
        -:  383:            realloc(2 * list_capacity);
        -:  384:        }
        -:  385:        list[list_size] = (value_pointer) ::operator new(sizeof(value_type));
        -:  386:        new(list[list_size++]) value_type(value_type(std::forward<Args>(args)...));
        -:  387:    }
        -:  388:
        -:  389:    /**
        -:  390:     * Destroys last element of the array.
        -:  391:     */
        -:  392:    void pop_back() {
        -:  393:        list[--list_size]->~T();
        -:  394:        ::operator delete(list[list_size], sizeof(value_type));
        -:  395:    }
        -:  396:
        -:  397:    /**
        -:  398:     * Destroys element at given position.\n
        -:  399:     * Shifts other elements to the left to fill the created gap.
        -:  400:     * @param position Position of element to be destroyed.
        -:  401:     */
        -:  402:    void pop(const long long position) {
        -:  403:        index_check(position);
        -:  404:        list[position]->~T();
        -:  405:        ::operator delete(list[position], sizeof(value_type));
        -:  406:        memmove(list + position, list + position + 1, sizeof(value_pointer) * (list_size-- - position));
        -:  407:    }
        -:  408:
        -:  409:    /**
        -:  410:     * Inserts given element before the given position.
        -:  411:     * @param value Element to be inserted.
        -:  412:     * @param positon Position where element is inserted.
        -:  413:     */
        -:  414:    void insert(const value_type &value, const long long position) {
        -:  415:        index_check(position);
        -:  416:        if (list_size >= list_capacity) {
        -:  417:            realloc(2 * list_capacity);
        -:  418:        }
        -:  419:
        -:  420:        memmove(list + position + 1, list + position, sizeof(value_pointer) * (list_size++ - position));
        -:  421:        /*
        -:  422:        for(auto i = list_size; i > position; i--)
        -:  423:            list[i] = list[i - 1];
        -:  424:        */
        -:  425:
        -:  426:        list[position] = new value_type;
        -:  427:        new(list[position]) value_type(value);
        -:  428:
        -:  429:    }
        -:  430:
        -:  431:    /**
        -:  432:     * Return a reference to the first element in array.
        -:  433:     * @return First element of array.
        -:  434:     */
        -:  435:    value_type &front() {
        -:  436:        return *list[0];
        -:  437:    }
        -:  438:
        -:  439:    /**
        -:  440:     * Return a const reference to the first element in array.
        -:  441:     * @return First element of array.
        -:  442:     */
        -:  443:    const value_type &front() const {
        -:  444:        return *list[0];
        -:  445:    }
        -:  446:
        -:  447:    /**
        -:  448:     * Return a reference to the last element in array.
        -:  449:     * @return Last element of array.
        -:  450:     */
        -:  451:    value_type &back() {
        -:  452:        return *list[list_size - 1];
        -:  453:    }
        -:  454:
        -:  455:    /**
        -:  456:     * Return a const reference to the last element in array.
        -:  457:     * @return Last element of array.
        -:  458:     */
        -:  459:    const value_type &back() const {
        -:  460:        return *list[list_size - 1];
        -:  461:    }
        -:  462:
        -:  463:
        -:  464:    /**
        -:  465:     * Allows use of operator [] to access array elements.
        -:  466:     * @param index Index at which element is situated.
        -:  467:     * @return Reference of element at given index.
        -:  468:     */
        -:  469:    value_type &operator[](long long index) {
        -:  470:        //enables use of [] for normal elements
        -:  471:        index_check(index);
        -:  472:        return *list[index];
        -:  473:    }
        -:  474:
        -:  475:
        -:  476:    /**
        -:  477:     * Allows use of operator [] to access array elements.
        -:  478:     * @param index Index at which element is situated.
        -:  479:     * @return Const reference of element at given index.
        -:  480:     */
        -:  481:    const value_type &operator[](long long index) const {
        -:  482:        //enables use of [] for const elements
        -:  483:        index_check(index);
        -:  484:        return *list[index];
        -:  485:    }
        -:  486:
        -:  487:    /**
        -:  488:     * Return an iterator at the start of the array.
        -:  489:     * @return Begin iterator.
        -:  490:     */
        -:  491:    iterator begin() const{
        -:  492:        return iterator(list);
        -:  493:    }
        -:  494:
        -:  495:    /**
        -:  496:     * Return an iterator just outside the end of the array.
        -:  497:     * @return End iterator.
        -:  498:     */
        -:  499:    iterator end() const{
        -:  500:        return iterator(list + list_size);
        -:  501:    }
        -:  502:
        -:  503:    /**
        -:  504:     * Replaces all current elements with given element.
        -:  505:     * @param value Element to be put in the array.
        -:  506:     */
        -:  507:    void fill(const value_type &value) {
        -:  508:        for (auto i = 0; i < list_size; i++) {
        -:  509:            list[i]->~T();
        -:  510:            new(list[i]) value_type(value);
        -:  511:        }
        -:  512:    }
        -:  513:
        -:  514:    /**
        -:  515:     * Return an iterator at the end of the array.
        -:  516:     * @return Reverse begin iterator.
        -:  517:     */
        -:  518:    iterator rbegin() const{
        -:  519:        return iterator(list + list_size - 1);
        -:  520:    }
        -:  521:
        -:  522:    /**
        -:  523:     * Return an iterator just outside the start of the array.
        -:  524:     * @return Reverse end iterator.
        -:  525:     */
        -:  526:    iterator rend() const{
        -:  527:        return iterator(list - 1);
        -:  528:    }
        -:  529:
        -:  530:    /**
        -:  531:     * Function that allows std::cout<< for array.
        -:  532:     * @param out Operator from std::cout.
        -:  533:     * @param arr Reference to array.
        -:  534:     * @return Array elements converted to std::cout.
        -:  535:     */
        -:  536:    friend std::ostream &operator<<(std::ostream &out, const array &arr) {
        -:  537:        out << "[";
        -:  538:        for (long long i = 0; i < arr.list_size - 1; i++){
        -:  539:            out << *(arr.list[i]) << ", ";
        -:  540:        }
        -:  541:        if (arr.list_size > 0) {
        -:  542:            out << arr.back();
        -:  543:        }
        -:  544:        out << "]";
        -:  545:        return out;
        -:  546:    }
        -:  547:
        -:  548://    /**
        -:  549://     * Function that allows std::fout<< for array.
        -:  550://     * @param out Operator from std::fout.
        -:  551://     * @param arr Reference to array.
        -:  552://     * @return Array elements converted to std::fout.
        -:  553://     */
        -:  554://    friend std::ofstream &operator<<(std::ofstream &out, const array &arr) {
        -:  555://        out << [;
        -:  556://        for (long long i = 0; i < arr.list_size - 1; i++)
        -:  557://            out << *(arr.list[i]) << ", ";
        -:  558://        if (arr.list_size > 0)
        -:  559://            out << arr.back();
        -:  560://        out << "]";
        -:  561://        return out;
        -:  562://    }
        -:  563:
        -:  564:    /**
        -:  565:     * Sort function using interchange sort.
        -:  566:     * @param cmp Optional compare parameter.\n
        -:  567:     * Must return an integer and contain 2 elements of array type as parameters.
        -:  568:     */
        -:  569:    void sort(std::function<int(const value_type& , const value_type&)> cmp = [](const value_type& a, const value_type& b){return a < b;}){
        -:  570:        for(int i = 0; i < list_size; i++) {
        -:  571:            for (int j = 0; j < list_size; j++){
        -:  572:                if (!cmp(*list[i], *list[j])){
        -:  573:                    swap(list[i], list[j]);
        -:  574:                }
        -:  575:            }
        -:  576:        }
        -:  577:    }
        -:  578:
        -:  579:    /**
        -:  580:     * Sort function that also accepts reverse parameter.
        -:  581:     * @param reverse Reverse parameter.
        -:  582:     * @param cmp Optional compare parameter.\n
        -:  583:     * Must return an integer and contain 2 elements of arrays type as parameters.
        -:  584:     */
        -:  585:    void sort(bool reverse, std::function<int(const value_type& , const value_type&)> cmp = [](const value_type& a, const value_type& b){return a < b;}){
        -:  586:        std::cout<<"alin\n";
        -:  587:        for(int i = 0; i < list_size; i++)
        -:  588:            for(int j = 0; j < list_size; j++)
        -:  589:                if(!cmp(*list[i], *list[j]) == reverse)
        -:  590:                    swap(list[i], list[j]);
        -:  591:        std::cout<<"bota\n";
        -:  592:    }
        -:  593:
        -:  594:    /**
        -:  595:     * Reverse the array.
        -:  596:     */
        -:  597:    void reverse(){
        -:  598:        for(long long i = 0, j = list_size - 1; i < j ; i++, j--)
        -:  599:            swap(list[i], list[j]);
        -:  600:    }
        -:  601:
        -:  602:    /**
        -:  603:     * Creates a new array filtered with given function.
        -:  604:     * @param cmp Filter function.\n
        -:  605:     * Must return integer and accept 1 element of arrays type as parameter.
        -:  606:     * @return New filtered list.
        -:  607:     */
        -:  608:    array filter_get(std::function<int(const value_type)> cmp){
        -:  609:        array<value_type> new_array;
        -:  610:        for(auto i: *this)
        -:  611:            if(cmp(i))
        -:  612:                new_array.push_back(i);
        -:  613:
        -:  614:        return new_array;
        -:  615:    }
        -:  616:
        -:  617:    /**
        -:  618:     * Filters array with given function.
        -:  619:     * @param cmp Filter function.\n
        -:  620:     * Must return integer and accept 1 element of arrays type as parameter.
        -:  621:     */
        -:  622:    void filter(std::function<int(const value_type)> cmp){
        -:  623:        long long i = 0;
        -:  624:        while(i<list_size)
        -:  625:            if(!cmp(*list[i]))
        -:  626:                pop(i);
        -:  627:            else
        -:  628:                i++;
        -:  629:    }
        -:  630:
        -:  631:    /**
        -:  632:     * Return position of first instance of given value in array.\n
        -:  633:     * If no instance is found function will return -1.
        -:  634:     * @param value Element to be searched.
        -:  635:     * @return Position of value in array.
        -:  636:     */
        -:  637:    long long search(const value_type& value) const{
        -:  638:        long long i = 0;
        -:  639:        while(i < list_size){
        -:  640:
        -:  641:            if(*list[i] == value)
        -:  642:                return i;
        -:  643:            i++;
        -:  644:        }
        -:  645:        return -1;
        -:  646:    }
        -:  647:
        -:  648://    long long search_if(std::function<int(const value_type)> condition) const{
        -:  649://        long long i = 0;
        -:  650://        while(i < list_size){
        -:  651://            if(condition(*list[i]))
        -:  652://                return i;
        -:  653://            i++;
        -:  654://        }
        -:  655://        return -1;
        -:  656://    }
        -:  657:
        -:  658:    /**
        -:  659:     * Return position of last instance of given value in array.\n
        -:  660:     * If no instance is found function will return -1.
        -:  661:     * @param value Element to be searched.
        -:  662:     * @return Position of value in array.
        -:  663:     */
        -:  664:    long long rsearch(const value_type& value) const{
        -:  665:        long long i = list_size - 1;
        -:  666:        while(i >= 0){
        -:  667:            if(*list[i] == value)
        -:  668:                return i;
        -:  669:        }
        -:  670:        return -1;
        -:  671:    }
        -:  672:};
        -:  673:
        -:  674:
